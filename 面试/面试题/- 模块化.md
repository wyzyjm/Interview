# 模块化

-   将一个复杂的程序按照一定的规则封装成几个文件,并进行组合.

## 好处

1. 避免命名冲突,
2. 更好的分离,按需加载
3. 高复用性, 可维护性.

## 问题: 前端如果没有模块化,会存在哪些问题:

-   变量污染, 命名冲突.
-   内部变量不能被外部访问.
-   文件间相互引用, 导入导出, 循环引用的问题

## 解决方案:

-   模块化是一种开发思想,为了解决全局变量冲突的问题

1. 最早期

-   命名空间: 就是将变量,函数等封装到一个对象里面.
-   闭包: 使污染的问题得到解决.
-   这些虽然大量的减少了全局变量的问题,但模块名暴露在全局,依旧存在变量名冲突的问题

2. 主流模块化解决方案

-   Common JS:

    -   加载模块是 同步的.只有一个加载完成才能执行后面的操作. 所以常被用在服务端.
    -   Node.js 就是采用 Commonjs 规范
    -   每一个 js 文件都是一个单独的模块.
    -   向外暴露: module.exports 或 exports. , 本质就是暴露 exports, exports 默认是一个空对象.
    -   引入模块: require 命令用于加载模块文件. 第三方包 直接包名, 自定义模块需要提供路径.
        -   实际是包的拷贝, 首次加载会缓存该模块.
    -   浏览器端可以用 Browserify 实现.

-   AMD:

    -   加载模块是异步的, 专门用于浏览器端.
    -   利用第三方库: require JS 来实现的
    -   模块定义:
        -   通过 define 定义模块, 第一个参数是数组形式依赖的模块,第二个参数是函数, 用来定义模块.
        -   return 向外暴露模块.
    -   模块调用: 使用通过配置 require.config,配置 path, require 第一个参数模块, 第二个参数是内容.

-   ES6 模块化:

    -   对比之前的优势在于: 编译过程中就完成模块加载.
    -   实际运行时,需要通过 babel 编译打包处理.
    -   导出:
        -   export default 只能有一个. 通常在只有一个导出, 比如 app 根组件导出.
        -   export 一个模块中可以有多个. 比如封装某个模块的 http 请求.
    -   导入:
        -   import
        -   `*`: 加载所有
        -   as: 使用别名.

-   CMD:

    -   有点 commonjs 和 AMD 规范的合体,
    -   定义模块:define, 三个参数, require,exports,module
    -   引入模块用 define 的参数, require
